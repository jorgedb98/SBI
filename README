
For PP we expect the researchers to provide the pdb file as pdb containing 2 chains from the protein


For Nuc-Peptide we expect the researchers to provide the pdb file as: chain1=peptide chain2+chain3 DNA or chain2=RNA
  1. compare DNAs and align
  if alignment over 95%, superimpose and make it new ref structure


Lili, 9th April:
  added to doc.md:
    - line 105 on DNA-prot complex
    - added some limitations

  NOTE:
  What if we have SINGLE strand RNA?
    I noticed 2 things about us seperating into nuc-prot or prot-prot, but maybe I am wrong...
    So first: in functions.py l.66 we check if the pdb holds 2 or 3 chains.
    But in case of single strand RNA, the pdb would hold 2 chains (1xProt 1xRNA), right?
    So here we would run the same script for prot-prot and rna-prot and only filter ourt dna-prot.

    Maybe it would be better to pass the complex type with the alpha_carbons_retriever(), since here
    we check if we are provided prot or nuc and then if nuc is DNA or RNA.

    This leads me to my second doubt :P ehehe

    Right now we only separate by PP or NP (if interaction="PP" / elif "NP"),
    but we cannot use the elif interaction="NP" loop starting line for RNA the way it is build to model with DNA
    (e.g there won't be a 3rd chain in the moving structure that can be compared at line 187)

    I'd suggest, we either:
          - change the read_pdb_files() from where we get interaction to return DP for DNA-Prot and RP for RNA_Prot
            so we can use another elif interaction =XX for RNA (that would be a lot of recycling from the DNA elif-loop)
            I'd say it makes sense to use the list of molecules from alpha_carbons_retriever() to distinguish between the different types
            We already call alpha_carbons_retriever() within the read_pdb_files(), so what do you think
            if we use the same system as we do right now with interaction ="PP"... only including RP and DP instead of NP?

    ... otherwise we might:
          - change the elif loop starting l.163 to be applicable to a pdb with 2 or 3 chains
            (if the alignment between ref_nucleotide and 2nd chain of mov_struc below threhsold
                and if there is a third chain for moving_structure: run alignment ref_stc and 3.chain of mov_strc)
            in this case we might rename all 'dna' to nucleotide there.



    Despite, I tried the thing to get the find clashes into a function:
    would replace code in line 136 and 207 (and could be used for RNA in case we separate DNA RNA)
    again, dos cosas:
            I included the "nc + 1 ". Since we did not introduce stechiometry for Nuc-Prot, we don't need ot there (yet)
            also, as input the fucntion would take either ref_atoms or ref_strcuture and same for moving.
            Personally, I would include the get_atoms() part in the function and pass it the structure objects instead.


      def check_for_clashes(ref_atoms, moving_atoms, options_verbose):
          """
          Check for clashes between moving structure and refernce structure
          after they have been superimposed.

          Argument: reference structure and moving structure

          Returns: reference structure (added if # of clashes below threshold)

          """

          # -------- WE COULD INCLUDE THIS IN THE FUNCTION and then take as arguments ref_structure and added_chain instead
          # ref_atoms=[]
          # for chain in ref_structure.get_chains():  #Get all the atom positions in the current reference structure
          #     ref_atoms.extend(alpha_carbons_retriever(chain,options.verbose)[0])
          #
          # moving_atoms = added_chain.get_atoms()

          Neighbor = NeighborSearch(ref_atoms) # using NeighborSearch from Biopython creating an instance Neighbor
          clashes = 0
          for atom in moving_atoms:     # Search for possible clashes between the atoms of the chain we want to add and the atoms already in the model
              atoms_clashed = Neighbor.search(atom.coord,5)

              if len(atoms_clashed) > 0:
                  clashes+=len(atoms_clashed)

          if clashes < 30:   #If the clashes do not exceed a certain threshold add the chain to the model
              present=[chain.id for chain in ref_structure.get_chains()]
              if added_chain.id in present:
                  added_chain.id= create_ID(present)  #create random id so it does not clash with the current chain ids in the PDB structure
              ref_structure[0].add(added_chain)
              if options_verbose:
                  sys.stderr.write("The chain %s was added to the model\n" % (added_chain.id))
          else:
              if options_verbose:
                  sys.stderr.write("Too many clashes. The chain %s was not added to the model\n" % (added_chain.id))
              continue

          nc + 1                                  # increase counter of chains in model

          return ref_structure
